name: reusable-build-wails-app
on:
  workflow_call:
    inputs:
      app_name:
        required: true
        type: string
        description: "Name of the Wails application"
      go_version:
        required: false
        type: string
        default: "1.21"
        description: "Go version to use for building"
      wails_version:
        required: false
        type: string
        default: "v2"
        description: "Wails version (v2 or specific version like v2.6.0)"
      node_version:
        required: false
        type: string
        default: "20"
        description: "Node.js version for frontend build"
      working_directory:
        required: false
        type: string
        default: "."
        description: "Working directory of the Wails project"
    secrets:
      WINDOWS_CERT_BASE64:
        required: false
        description: "Base64-encoded Windows code signing certificate"
      WINDOWS_CERT_PASSWORD:
        required: false
        description: "Password for Windows code signing certificate"
      APPLE_CERT_BASE64:
        required: false
        description: "Base64-encoded Apple Developer certificate"
      APPLE_CERT_PASSWORD:
        required: false
        description: "Password for Apple Developer certificate"
      APPLE_ID:
        required: false
        description: "Apple ID for notarization"
      APPLE_TEAM_ID:
        required: false
        description: "Apple Team ID for notarization"
      token:
        required: false
        description: "GitHub token for uploading release assets"
permissions:
  contents: write
jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: windows
            os: windows-latest
            arch: amd64
            extension: .exe
          - platform: darwin
            os: macos-latest
            arch: amd64
            extension: .app
          - platform: darwin
            os: macos-latest
            arch: arm64
            extension: .app
          - platform: linux
            os: ubuntu-latest
            arch: amd64
            extension: ""
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ inputs.go_version }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node_version }}

      - name: Install Wails
        shell: bash
        run: |
          if [ "${{ inputs.wails_version }}" = "v2" ]; then
            go install github.com/wailsapp/wails/v2/cmd/wails@latest
          else
            go install github.com/wailsapp/wails/v2/cmd/wails@${{ inputs.wails_version }}
          fi

      # Linux-specific dependencies
      - name: Install Linux dependencies
        if: matrix.platform == 'linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.0-dev
          # Install tools for creating AppImage and .deb
          wget -q https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage
          chmod +x linuxdeploy-x86_64.AppImage
          sudo mv linuxdeploy-x86_64.AppImage /usr/local/bin/linuxdeploy

      # Windows code signing setup
      - name: Setup Windows code signing
        if: matrix.platform == 'windows' && secrets.WINDOWS_CERT_BASE64 != ''
        shell: pwsh
        run: |
          $certBytes = [Convert]::FromBase64String("${{ secrets.WINDOWS_CERT_BASE64 }}")
          $certPath = Join-Path $env:TEMP "cert.pfx"
          [IO.File]::WriteAllBytes($certPath, $certBytes)
          echo "CERT_PATH=$certPath" >> $env:GITHUB_ENV
          echo "CERT_PASSWORD=${{ secrets.WINDOWS_CERT_PASSWORD }}" >> $env:GITHUB_ENV

      # macOS code signing setup
      - name: Setup macOS code signing
        if: matrix.platform == 'darwin' && secrets.APPLE_CERT_BASE64 != ''
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate
          CERT_PATH=$RUNNER_TEMP/cert.p12
          echo "${{ secrets.APPLE_CERT_BASE64 }}" | base64 --decode > $CERT_PATH
          security import $CERT_PATH -P "${{ secrets.APPLE_CERT_PASSWORD }}" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "APPLE_SIGNING_ENABLED=true" >> $GITHUB_ENV

      # Get version from the project
      - name: Get application version
        id: version
        shell: bash
        working-directory: ${{ inputs.working_directory }}
        run: |
          # Try to extract version from wails.json
          if [ -f wails.json ]; then
            VERSION=$(cat wails.json | grep -o '"version"[[:space:]]*:[[:space:]]*"[^"]*"' | cut -d'"' -f4 || echo "dev")
          else
            VERSION="dev"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      # Build the application
      - name: Build Wails application
        shell: bash
        working-directory: ${{ inputs.working_directory }}
        run: |
          BUILD_PLATFORM="${{ matrix.platform }}"
          BUILD_ARCH="${{ matrix.arch }}"

          # Build for the target platform
          wails build -platform ${BUILD_PLATFORM}/${BUILD_ARCH} -clean

      # Windows: Sign the executable
      - name: Sign Windows executable
        if: matrix.platform == 'windows' && secrets.WINDOWS_CERT_BASE64 != ''
        shell: pwsh
        working-directory: ${{ inputs.working_directory }}
        run: |
          $exePath = Get-ChildItem -Path "build/bin" -Filter "*.exe" -Recurse | Select-Object -First 1 -ExpandProperty FullName
          if ($exePath) {
            signtool sign /f $env:CERT_PATH /p $env:CERT_PASSWORD /tr http://timestamp.digicert.com /td sha256 /fd sha256 $exePath
            Write-Host "Signed: $exePath"
          } else {
            Write-Error "Error: No .exe file found in build/bin. Build may have failed."
            exit 1
          }

      # macOS: Create .app bundle and .dmg
      - name: Create macOS .dmg
        if: matrix.platform == 'darwin'
        shell: bash
        working-directory: ${{ inputs.working_directory }}
        run: |
          APP_NAME="${{ inputs.app_name }}"
          VERSION="${{ steps.version.outputs.version }}"
          ARCH="${{ matrix.arch }}"

          # Find the .app bundle
          APP_PATH=$(find build/bin -name "*.app" -type d | head -n 1)

          if [ -z "$APP_PATH" ]; then
            echo "Error: .app bundle not found"
            exit 1
          fi

          # Sign the app if certificate is available
          if [ "$APPLE_SIGNING_ENABLED" = "true" ]; then
            codesign --force --deep --sign "Apple Development" "$APP_PATH"
          fi

          # Create DMG
          DMG_NAME="${APP_NAME}-${VERSION}-darwin-${ARCH}.dmg"
          mkdir -p dmg
          cp -r "$APP_PATH" dmg/
          hdiutil create -volname "$APP_NAME" -srcfolder dmg -ov -format UDZO "$DMG_NAME"

          # Notarize if credentials are available
          if [ -n "${{ secrets.APPLE_ID }}" ] && [ -n "${{ secrets.APPLE_TEAM_ID }}" ] && [ "$APPLE_SIGNING_ENABLED" = "true" ]; then
            xcrun notarytool submit "$DMG_NAME" --apple-id "${{ secrets.APPLE_ID }}" --team-id "${{ secrets.APPLE_TEAM_ID }}" --password "${{ secrets.APPLE_CERT_PASSWORD }}" --wait
            xcrun stapler staple "$DMG_NAME"
          fi

          echo "DMG_PATH=$DMG_NAME" >> $GITHUB_ENV

      # Linux: Create AppImage and .deb
      - name: Create Linux packages
        if: matrix.platform == 'linux'
        shell: bash
        working-directory: ${{ inputs.working_directory }}
        run: |
          APP_NAME="${{ inputs.app_name }}"
          VERSION="${{ steps.version.outputs.version }}"
          ARCH="${{ matrix.arch }}"

          # Find the binary
          BINARY_PATH=$(find build/bin -type f -executable | head -n 1)

          if [ -z "$BINARY_PATH" ]; then
            echo "Error: Binary not found"
            exit 1
          fi

          BINARY_NAME=$(basename "$BINARY_PATH")

          # Create AppImage
          mkdir -p AppDir/usr/bin
          cp "$BINARY_PATH" AppDir/usr/bin/

          # Create desktop file
          mkdir -p AppDir/usr/share/applications
          cat > AppDir/usr/share/applications/${APP_NAME}.desktop << EOF
          [Desktop Entry]
          Name=${APP_NAME}
          Exec=${BINARY_NAME}
          Icon=${APP_NAME}
          Type=Application
          Categories=Utility;
          EOF

          # Create AppImage (if linuxdeploy is available)
          if command -v linuxdeploy &> /dev/null; then
            linuxdeploy --appdir AppDir --output appimage || echo "AppImage creation skipped"
          fi

          # Create .deb package structure
          DEB_DIR="${APP_NAME}_${VERSION}_${ARCH}"
          mkdir -p "${DEB_DIR}/DEBIAN"
          mkdir -p "${DEB_DIR}/usr/bin"
          cp "$BINARY_PATH" "${DEB_DIR}/usr/bin/"

          # Create control file
          cat > "${DEB_DIR}/DEBIAN/control" << EOF
          Package: $(echo "${APP_NAME}" | tr '[:upper:]' '[:lower:]')
          Version: ${VERSION}
          Section: utils
          Priority: optional
          Architecture: ${ARCH}
          Maintainer: Your Name <your.email@example.com>
          Description: ${APP_NAME} application
           Built with Wails
          EOF

          # Build .deb
          dpkg-deb --build "${DEB_DIR}"

          echo "BINARY_PATH=$BINARY_PATH" >> $GITHUB_ENV
          echo "DEB_PATH=${DEB_DIR}.deb" >> $GITHUB_ENV

      # Prepare artifacts with proper naming
      - name: Prepare artifacts
        id: prepare
        shell: bash
        working-directory: ${{ inputs.working_directory }}
        run: |
          APP_NAME="${{ inputs.app_name }}"
          VERSION="${{ steps.version.outputs.version }}"
          PLATFORM="${{ matrix.platform }}"
          ARCH="${{ matrix.arch }}"

          mkdir -p artifacts

          if [ "$PLATFORM" = "windows" ]; then
            EXE_PATH=$(find build/bin -name "*.exe" | head -n 1)
            ARTIFACT_NAME="${APP_NAME}-${VERSION}-windows-${ARCH}.exe"
            cp "$EXE_PATH" "artifacts/$ARTIFACT_NAME"
            echo "artifacts=artifacts/$ARTIFACT_NAME" >> $GITHUB_OUTPUT

          elif [ "$PLATFORM" = "darwin" ]; then
            # Use the DMG created earlier
            if [ -f "$DMG_PATH" ]; then
              mv "$DMG_PATH" artifacts/
              echo "artifacts=artifacts/$DMG_PATH" >> $GITHUB_OUTPUT
            fi

          elif [ "$PLATFORM" = "linux" ]; then
            ARTIFACT_FILES=""

            # Add binary
            BINARY_PATH=$(find build/bin -type f -executable | head -n 1)
            if [ -f "$BINARY_PATH" ]; then
              BINARY_ARTIFACT="${APP_NAME}-${VERSION}-linux-${ARCH}"
              cp "$BINARY_PATH" "artifacts/$BINARY_ARTIFACT"
              ARTIFACT_FILES="artifacts/$BINARY_ARTIFACT"
            fi

            # Add AppImage if it exists
            APPIMAGE=$(find . -name "*.AppImage" | head -n 1)
            if [ -f "$APPIMAGE" ]; then
              APPIMAGE_ARTIFACT="${APP_NAME}-${VERSION}-linux-${ARCH}.AppImage"
              cp "$APPIMAGE" "artifacts/$APPIMAGE_ARTIFACT"
              ARTIFACT_FILES="$ARTIFACT_FILES artifacts/$APPIMAGE_ARTIFACT"
            fi

            # Add .deb
            if [ -f "$DEB_PATH" ]; then
              DEB_ARTIFACT="${APP_NAME}-${VERSION}-linux-${ARCH}.deb"
              cp "$DEB_PATH" "artifacts/$DEB_ARTIFACT"
              ARTIFACT_FILES="$ARTIFACT_FILES artifacts/$DEB_ARTIFACT"
            fi

            echo "artifacts=$ARTIFACT_FILES" >> $GITHUB_OUTPUT
          fi

      # Generate SHA256 checksums
      - name: Generate checksums
        shell: bash
        working-directory: ${{ inputs.working_directory }}
        run: |
          cd artifacts
          if [ "${{ matrix.platform }}" = "windows" ]; then
            pwsh -Command "Get-ChildItem | ForEach-Object { (Get-FileHash $_.FullName -Algorithm SHA256).Hash + '  ' + $_.Name } | Out-File checksums.txt"
          else
            sha256sum * > checksums.txt
          fi

      # Upload to GitHub Release
      - name: Upload artifacts to release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            ${{ inputs.working_directory }}/artifacts/*
        env:
          GITHUB_TOKEN: ${{ secrets.token || secrets.GITHUB_TOKEN }}
